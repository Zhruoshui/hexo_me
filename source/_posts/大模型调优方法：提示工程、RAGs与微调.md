---
title: 大模型调优方法：提示工程、RAGs与微调
description: 模型领域智能
categories:
  - 必学开发技能
abbrlink: 43169
date: 2025-09-22 10:40:57
tags:
cover: https://b0.bdstatic.com/ugc/ex66jsc1SBbe8Mnilmv9xgeeddcdf08194a3fd0c69b0bd9fe28a7b.jpg
swiper_index:
---


# 参考文章
{% link RAG还是微调——企业应用大模型怎么选？, https://zhuanlan.zhihu.com/p/690173481,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%} 

{% link 大语言模型检索增强生成（RAG）综述, https://zhuanlan.zhihu.com/p/1902692598159765770,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%} 

{% link RAG最全面综述, https://zhuanlan.zhihu.com/p/676162484,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%}

{% link 一文详解：8种常见的大模型微调方法，看这篇就够了, https://zhuanlan.zhihu.com/p/676162484,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%}

{% link 大模型炼丹术：大模型微调总结及实现, https://zhuanlan.zhihu.com/p/673789772,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%}

{% link 五个最流行的大模型微调框架, https://zhuanlan.zhihu.com/p/32447713050,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%}

{% link 提示词工程指南, https://www.promptingguide.ai/zh%} 

{% link 2025年值得关注的21个RAG开源项目, https://blog.csdn.net/m0_59235699/article/details/146988498,  https://image.aruoshui.fun/i/2025/01/02/ni2zi4-0.webp%} 

{% link 三分钟带你看完大模型微调框架：5个开源框架+4个闭源平台一站式掌握, https://blog.csdn.net/2401_85116933/article/details/151026385,  https://image.aruoshui.fun/i/2025/01/02/ni2zi4-0.webp%} 

{% link 先进的 RAG 技术：提升检索增强生成系统, https://github.com/NirDiamant/RAG_Techniques,  https://image.aruoshui.fun/i/2025/01/13/p2416y-0.webp%}

{% link RAG 与微调在大模型应用中如何抉择, https://juejin.cn/post/7332741965673480231?searchId=20250922100743CFC54AF2D0E5B532A2C3,  https://image.aruoshui.fun/i/2025/09/22/hijfn6-0.webp%} 

# 当通用大模型遇上企业专属需求
2025年，大模型（LLM）已如水电般普及。GPT、Claude、Qwen-Max、Llama 3 等模型在通用能力上日趋成熟，推理、写作、编程、多模态几乎无所不能。然而，当这些“通才”进入企业场景 —— 如金融合规、医疗问诊、客户服务、产品推荐 —— 却常常“力不从心”。

为什么？因为企业需要的是：
- **领域专业知识（不是通用百科）**
- **风格一致性（不是自由发挥）**
- **事实准确性 + 可追溯性（不是一本正经胡说八道）**
- **快速响应业务变化（不是等三个月重训模型）**

于是，三大调优方法应运而生：
{% note success flat %}
**提示工程（Prompt Engineering）→ RAG（检索增强生成）→ 微调（Fine-tuning）**
{% endnote %}

![图1](https://image.aruoshui.fun/i/2025/09/22/iggk9n-0.webp)
![图2](https://baoyu.io/images/ai-paper/2312.10997/RAG_FT.png)

# 提示工程（Prompt Engineering）—— 最轻量、最灵活的“对话引导术”

在 2025 年，大模型能力已高度同质化（GPT-4o、Claude 3.5、Qwen-Max、Llama 3.1 等通用能力接近），真正的差异化来自“你怎么问” —— 这就是提示词工程的价值。

提示工程相对是使用AI时接触比较多的概念，输入prompt给large language model，大语言模型就根据这个输入来生成回应。然后得到我们想要的结果。

这实际上是一种精确的输入方法，旨在引导模型产生相应的输出。大多数情况下prompts指的是文本，尤其是以自然语言来作为描述的文本。

## 提示词的核心技巧
{% note success flat %}
以下参考：[精选提示词集、提示词模板](https://www.aishort.top/)
{% endnote %}
1. 角色设定
   让模型“扮演”特定角色，输出符合身份的语气和知识。
   ✅ 适用场景：客服、法律、医疗、教育等专业领域
   ✅ 效果：语气更专业、术语更准确、避免“学生腔”或“百科腔”
   ```text
    你是一位资深金融合规顾问，拥有10年银行风控经验。请用专业但易懂的语言，向客户解释“反洗钱客户尽职调查（CDD）”的基本流程。
    ```
2. 少样本学习
   提供几个输入-输出示例，让模型“举一反三”。
   ✅ 适用场景：分类、翻译、格式转换、实体识别
   ✅ 效果：显著提升小样本任务准确率，尤其适合结构化输出
   ```text
    请将以下用户问题分类为【技术咨询】【价格咨询】【售后问题】：

    示例1：
    用户：“我的订单还没发货？”
    分类：售后问题
    
    示例2：
    用户：“你们支持API对接吗？”
    分类：技术咨询
    
    现在请分类：
    用户：“这个套餐能便宜点吗？”
   ```
3. 思维链
   引导模型“分步思考”，提升复杂推理能力。
   ✅ 适用场景：数学题、逻辑推理、多跳问答、因果分析
   ✅ 效果：提升模型“慢思考”能力，减少直觉错误
   ```text
    小明有5个苹果，他吃掉2个，又买了3个，然后送人1个。请问他现在有几个苹果？请一步步思考。

    第一步：原有5个  
    第二步：吃掉2个 → 5 - 2 = 3  
    第三步：买3个 → 3 + 3 = 6  
    第四步：送人1个 → 6 - 1 = 5  
    答案：5个苹果
  ```
1. 输出约束
   强制模型按指定格式输出，便于程序解析。
   ✅ 适用场景：API对接、数据提取、自动化流程
   ✅ 效果：避免自由文本，提升系统集成效率
    ```text
     请将以下文本中的关键信息提取为JSON格式：
    
     文本：“张三，男，30岁，住在北京，电话1234567890。”
    
     输出格式：
     {
        "姓名": "",
        "性别": "",
        "年龄": ,
        "城市": "",
        "电话": ""
     }
    ```
2. 分步指令（Step-by-Step Instruction）
   拆解复杂任务，降低模型认知负荷。
   ✅ 适用场景：内容创作、报告生成、项目策划
   ✅ 效果：结构更清晰、内容更完整、避免遗漏关键点
    ```text
     请帮我写一篇关于“人工智能在医疗中的应用”的文章，包含以下部分：
     1. 引言
     2. 人工智能技术概述
     3. 医疗领域的主要应用场景
     4. 案例分析
     5. 挑战与未来展望
     6. 结论
    ```
3. 负面约束、禁忌词
   明确告诉模型“不要做什么”，避免错误或敏感输出。
   ✅ 适用场景：合规场景、儿童内容、品牌安全
   ✅ 效果：降低幻觉、规避风险、控制风格
    ```text
     请撰写一篇关于“气候变化”的文章，但不要提及政治话题或使用任何冒犯性语言。
    ```
4. 自我反思、自洽性检查
   ✅ 适用场景：事实核查、数据验证、高风险决策
   ✅ 效果：触发模型“二次思考”，减少低级错误
    ```text
     请解释“量子计算”的基本原理，并检查你的解释是否有逻辑漏洞或不准确之处。
    ```

{% note info flat %}
通过精心设计输入提示（Prompt），引导大模型输出符合预期的结果，无需修改模型参数。
{% endnote %}

## 提示词技术
详见[提示词工程指南](https://www.promptingguide.ai/zh)

![链式思考提示](https://image.aruoshui.fun/i/2025/09/22/p55h0r-0.webp)

补充一些没有提及的：

1. AI优化提示词：使用 LLM 自动改写 Prompt，寻找更优表达（用于你不会表述该问题，或者想要更高效的表达方式）
2. 动态提示词：根据用户画像、历史行为、上下文实时调整 Prompt

## 提示词编排
### 提示词编排的核心要素

1. **明确性**：确保你的提示是清晰且具体的。避免模糊不清的指令，这样可以使模型更容易理解你想要的结果。

2. **结构化**：给定的任务可以通过分步骤来完成。例如，在要求模型进行复杂的推理时，可以让它一步一步地思考问题。

3. **上下文**：提供足够的背景信息，以便模型能够更好地理解任务的要求。这可能包括提供特定领域的术语或先前对话的历史记录。

4. **约束条件**：指定输出的格式、长度或其他限制条件，以控制生成内容的形式。

5. **少样本学习（Few-shot Learning）**：在提示中包含几个例子可以帮助模型理解你期望的输出样式。

6. **角色设定**：为模型设定一个角色，比如“作为一个专业的医学研究员”，这有助于引导回答的风格和深度。

7. **使用魔法词**：某些特定的短语或词语可能会触发模型给出更好的回应。例如，“Let’s think step by step”可以促使模型逐步分析问题。

### 实践中的技巧

- **迭代优化**：不断地测试和调整提示词，直到达到满意的效果。
- **负面提示**：告诉模型不要做什么，比如避免使用某些词汇或概念。
- **动态调整**：根据对话的发展，实时调整提示策略。

### 工具和库

- **LangChain** 和 **LlamaIndex**：这两个开源项目提供了构建复杂提示工程的能力，包括链式调用和知识检索增强生成（RAG）等功能。
- **Promptfoo** 和 **LangSmith**：用于测试和优化提示词效果的工具。
- **Hugging Face Transformers**：提供了强大的API来与预训练的语言模型交互，并允许用户自定义提示。

### 资源链接
- [OpenAI的官方指南](https://platform.openai.com/docs/guides/prompt-engineering)
- [Google的Prompt Engineering白皮书](https://drive.google.com/file/d/1AbaBYbEa_EbPelsT40-vj64L-2IwUJHy/view)（英文原版）
- [DAIR.AI的Prompt Engineering Guide](https://www.promptingguide.ai/)
- [Awesome ChatGPT Prompts](https://prompts.chat/)：一个收集了大量实用提示词的社区。

## 提示词的缺陷
1. **缺乏深度专业知识**
   - **问题**：虽然大语言模型（LLM）可以生成看起来合理的文本，但它们可能并不具备特定领域的深入知识或最新的研究成果。
   - **解决方案**：可以通过RAG（检索增强生成）结合外部知识库来补充这一不足。

2. **幻觉问题**
   - **问题**：模型可能会产生看似合理但实际上错误的信息，尤其是在涉及复杂的专业概念或事实性信息时。
   - **解决方案**：通过引入验证步骤、使用高质量数据进行微调或者结合RAG技术来减少错误率。

3. **上下文长度限制**
   - **问题**：大多数模型都有处理上下文长度的限制，这意味着对于需要大量背景信息才能准确回答的问题，模型可能无法提供满意的答案。
   - **解决方案**：分段输入上下文或将关键信息预先提取出来作为输入的一部分。

4. **一致性与稳定性**
   - **问题**：即使是相同的提示，在不同的时间点或模型版本上运行，也可能得到不同的结果，这在要求高一致性的专业环境中是不可接受的。
   - **解决方案**：定期评估并更新提示词，同时监控模型输出的一致性，并根据需要调整策略。

5. **成本效益**
   - **问题**：为了达到理想的效果，可能需要大量的实验和迭代，这对资源消耗较大，尤其是当涉及到频繁使用的API调用时。
   - **解决方案**：优化提示词设计流程，采用更高效的工具和技术手段降低整体成本。

# RAG（Retrieval-Augmented Generation）—— 用外部知识库武装大模型


{% note warning flat %}
**目前大语言模型 (LLMs) 仍面临诸如幻觉式错误、知识更新以及数据相关问题的挑战。**这些问题影响了大语言模型的可靠性，在一些严肃的任务场景中，尤其是在需要广泛知识的知识密集型任务
{% endnote %}

{% note primary flat %}
以下内容参考：
1. 论文：Retrieval-Augmented Generation for Large Language Models: A Survey
2. 链接：https://arxiv.org/abs/2312.10997
3. 翻译：https://baoyu.io/translations/ai-paper/2312.10997-retrieval-augmented-generation-for-large-language-models-a-survey

{% endnote %}

Retrieval-Augmented Generation（RAG），即检索增强生成，是一种结合信息检索与语言生成的人工智能技术框架。它旨在通过从外部知识库中提取相关信息，并将其与生成模型相结合，以形成更准确、更具上下文相关性的回答或内容，从而提升大型语言模型（LLM）在处理知识密集型任务时的表现。

![RAG研究](https://baoyu.io/images/ai-paper/2312.10997/timeline.jpg)

RAG 的方法使得开发人员无需为每一个特定任务重新训练整个庞大的模型。他们可以简单地给模型加上一个知识库，通过这种方式增加模型的信息输入，从而提高回答的精确性。RAG 特别适用于那些需要大量知识的任务。

{% note info flat %}
首先，任何的大模型一旦训练完成就变成了一个静态的文件，它只存储了在训练过程中提供给它的知识（数据）。因此，当你问 ChatGPT 自己公司内部规章制度的相关规定，它必定无法准确回答，而且还会给出误导性的答案。

为了解决这个问题，最简单的方式就是先告诉大模型这些规定，然后再让它回答。这种方式就是提示词工程中的多样本学习（few-short learning）。

同时，大模型是没有记忆的，你提出的每一个问题其实对他来说都是全新的问题。当我们需要为模型提供更多上下文的时候，就需要用到 RAG 技术。

RAG 是在给模型发送消息之前首先进行内容检索，从其他数据源把相关的数据先提取出来，然后插入到当前对话消息中给到模型，这样就解决了既要让模型知晓大量它不知道的知识，又避免消息窗口不够的局限。
{% endnote %}

## RAG的优势
目前的研究已经表明，检索增强生成 在优化大语言模型方面，相较于其他方法具有显著的优势。

![RAG技术](https://image.aruoshui.fun/i/2025/09/22/qq711j-0.webp)

- RAG 通过关联外部知识来提高答案的准确性，有效减少了语言模型中出现的虚假信息，使得生成的回答更加准确可信。
- 使用检索技术能够识别到最新的信息，这使得 RAG 在保持回答的及时性和准确性方面，相较于只依赖训练数据的传统语言模型有明显优势。
- RAG 的透明度是其一大优点。通过引用信息来源，用户可以核实答案的准确性，这增强了人们对模型输出结果的信任。
- RAG 具备高度的定制化能力。通过索引与特定领域相关的文本语料库，RAG 能够为不同领域提供专业的知识支持。
- 在安全性和隐私管理方面，RAG 通过数据库中设置的角色和安全控制，实现了对数据使用的更好控制。相比之下，经过微调的模型在管理数据访问权限方面可能不够明确。
- RAG 在处理大规模数据集方面更具有扩展性。它无需更新所有参数和创建新的训练集，因此在经济效率方面更具优势。
- 最后，RAG 提供的结果更加值得信赖。RAG 从最新数据中提取确定性的结果，而经过微调的模型在处理动态数据时可能会产生错误信息和不准确之处，缺乏透明度和可信度。

## 著名的RAG项目
![github星标项目排布](https://image.aruoshui.fun/i/2025/09/22/qvmo8o-0.webp)
这里举例几个，详细的可以前往github搜索：
### ragflow
{% note info flat %}
RAGFlow 是一款基于深度文档理解构建的开源 RAG 引擎。RAGFlow 可以为各种规模的企业及个人提供一套精简的 RAG 工作流程，结合大语言模型（LLM）针对用户各类不同的复杂格式数据提供可靠的问答以及有理有据的引用。
{% endnote %}
![ragflow](https://s2.loli.net/2024/11/25/gl9OhzJcwuGHMid.png)
- 网址：https://github.com/infiniflow/ragflow
- 特点：简化的工作流设计，内置预构建组件，并与向量数据库集成。
- 适用对象：希望快速构建 RAG 应用的开发者和组织。
- 工作流设计：直观的界面用于设计和配置 RAG 工作流。
- 预配置工作流：提供常见场景的即用型工作流。
- 向量数据库集成：与向量数据库无缝集成，实现高效检索。
- 应用场景：实时应用，如聊天机器人和即时问答系统。
- 用户体验：用户友好且高效，降低了学习曲线和开发时间。

### FlashRAG
{% note info flat %}
FlashRAG是一个用于复现和开发检索增强生成（RAG）研究的Python工具包。我们的工具包包括36个预处理的基准RAG数据集和17个最先进的RAG算法。
{% endnote %}

![架构图](https://github.com/RUC-NLPIR/FlashRAG/raw/main/asset/framework.jpg)
- 网址：https://github.com/RUC-NLPIR/FlashRAG
- 特点：针对推理速度进行了优化，采用了多种加速技术。
- 适用对象：适用于需要实时 RAG 应用的开发者和组织。
- 功能：支持多种检索模型、经过优化的重排序器以及高性能生成器。
- 应用场景：例如在线客户支持和智能助手等需要即时、准确响应的系统。
- 优势：在保持准确性的同时，显著降低了推理延迟。


# 微调（Fine-tuning）—— 让模型“内化”你的领域DNA
在大语言模型的优化过程中，除了 RAG，微调也是一种重要的技术。

{% note info flat %}
随着大语言模型（LLM）技术的快速发展，企业对定制化AI解决方案的需求日益增长。在这一背景下，大模型微调（Fine-tuning）技术成为实现模型专业化、提升特定领域性能的关键手段。本报告旨在系统阐述当前主流的大模型微调技术，为公司在历史数据基础上构建专业领域模型提供技术指导。
{% endnote %}

{% note info flat %}
可以把 RAG 想象成给模型提供一本教科书，让它根据特定的问题去查找信息。这种方法适用于模型需要解答具体问题或执行特定信息检索任务的情况。但 RAG 并不适合于教会模型理解广泛的领域或学习新的语言、格式或风格。
{% endnote %}

而微调更像是让学生通过广泛学习来吸收知识:

1. 当模型需要模仿特定的结构、风格或格式时，微调就显得非常有用。它可以提高未经微调的模型的表现，使交互更加高效。

2. 微调特别适用于强化模型已有的知识、调整或定制模型的输出，以及给模型下达复杂的指令。然而，微调并不适合于向模型中添加新的知识，或者在需要快速迭代新场景的情况下使用。

3. 微调 (Fine-tuning) 的过程就像是让学生通过深入持久的学习来吸收知识。这种方法适用于在模型需要精确模仿特殊的结构、艺术风格或者格式时。微调能够使模型的表现超越未经微调的模型，并提升交互效率。它尤其适合于突出模型基础知识库中已有的知识，调整或定制模型输出，并以复杂的指引来训练模型。然而，微调并不适合于向模型中增加全新的知识，或应对那些需要快速迭代新场景的情况。

RAG 和微调可以相互补充，而非相互排斥，从而在不同层次上增强模型的能力。在特定情况下，结合这两种方法可以达到模型性能的最佳状态。整个利用 RAG 和微调进行优化的过程可能需要多轮迭代才能获得满意的成果。

## 大模型微调的基本概念与流程

大模型微调是指在大规模预训练语言模型的基础上，通过特定任务或领域的数据进行二次训练，以调整模型参数，使其更好地适应目标任务的过程。微调的本质是将预训练模型在通用知识上的学习能力，迁移到特定领域的专业能力上。

### 微调的基本流程

1. **预训练模型选择**：选择适合目标任务的预训练模型（如Gemma、Qwen、Llama等）
2. **数据准备**：收集、清洗和标注特定领域的数据集
3. **微调配置**：确定微调方法、超参数和训练策略
4. **模型训练**：使用特定数据集进行微调
5. **评估与验证**：通过测试集评估微调后模型的性能
6. **部署与应用**：将微调后的模型集成到业务系统中

### 微调方法
微调可以分为全微调和重用两个方法：

1. **全微调（Full Fine-tuning）**：全微调是指对整个预训练模型进行微调，包括所有的模型参数。在这种方法中，预训练模型的所有层和参数都会被更新和优化，以适应目标任务的需求。这种微调方法通常适用于任务和预训练模型之间存在较大差异的情况，或者任务需要模型具有高度灵活性和自适应能力的情况。Full Fine-tuning需要较大的计算资源和时间，但可以获得更好的性能。
2. **部分微调（Repurposing）**：部分微调是指在微调过程中只更新模型的顶层或少数几层，而保持预训练模型的底层参数不变。这种方法的目的是在保留预训练模型的通用知识的同时，通过微调顶层来适应特定任务。Repurposing通常适用于目标任务与预训练模型之间有一定相似性的情况，或者任务数据集较小的情况。由于只更新少数层，Repurposing相对于Full Fine-tuning需要较少的计算资源和时间，但在某些情况下性能可能会有所降低。

### 微调预训练模型的方法：
- 微调所有层：将预训练模型的所有层都参与微调，以适应新的任务。
- 微调顶层：只微调预训练模型的顶层，以适应新的任务。
- 冻结底层：将预训练模型的底层固定不变，只对顶层进行微调。
- 逐层微调：从底层开始，逐层微调预训练模型，直到所有层都被微调。
- 迁移学习：将预训练模型的知识迁移到新的任务中，以提高模型性能。这种方法通常使用微调顶层或冻结底层的方法

### 全量微调（Full Fine-tuning）

**定义**：更新模型所有参数的微调方法。

**原理**：在预训练模型的基础上，使用特定任务数据集对所有参数进行训练，使模型完全适应目标任务。

**优势**：
- 能够达到最佳性能
- 适用于数据量充足、计算资源丰富的场景

**劣势**：
- 计算成本高，需要大量GPU资源
- 显存需求大，难以在消费级硬件上运行
- 易发生过拟合，需要大量数据支持

**适用场景**：当企业拥有大量高质量标注数据，且计算资源充足时，全量微调是最佳选择。

### 低秩适应（LoRA）

**定义**：一种参数高效微调方法，通过在预训练模型的层间添加低秩矩阵来引入新参数。

**原理**：在模型权重矩阵W中添加低秩分解形式的增量ΔW = BA，其中A∈R^(d×r)，B∈R^(r×k)，r<<d,k。微调时仅更新A和B，保持原始权重W不变。

**优势**：
- 计算成本低，参数量减少99%以上
- 过拟合风险小
- 能够快速适应新任务
- 对预训练模型的原始性能影响小

**劣势**：
- 在某些复杂任务上可能无法达到全量微调的效果
- 需要精心设计低秩矩阵的结构和参数

**实现示例**：
```python
from peft import LoraConfig, get_peft_model

lora_config = LoraConfig(
    r=8,  # 低秩维度
    lora_alpha=32,
    target_modules=["q_proj", "v_proj"],  # 目标层
    lora_dropout=0.1,
    bias="none",
    task_type="CAUSAL_LM"
)

model = get_peft_model(model, lora_config)
```

**应用案例**：在知识库问答系统中，使用LoRA微调可以快速适应特定领域的术语和问答模式，而无需重新训练整个模型。

### Adapter-Tuning

**定义**：一种微调技术，通过在预训练模型中添加小型的、可学习的模块来适配特定任务。

**原理**：在原始模型的每一层插入小型网络模块（称为Adapter），只训练这些Adapter的参数，而保持原始模型参数不变。

**优势**：
- 参数高效，计算成本低
- 适合多任务学习，不同任务可以共享主干网络
- 对原始模型结构干扰小

**劣势**：
- 需要设计合理的Adapter结构
- 在某些任务上可能不如LoRA高效

**实现示例**：
```python
from peft import get_peft_model, PromptEncoderConfig

adapter_config = PromptEncoderConfig(
    task_type="CAUSAL_LM",
    num_virtual_tokens=20,
    encoder_hidden_size=128,
    dropout=0.1
)

model = get_peft_model(model, adapter_config)
```

### Prefix-Tuning

**定义**：针对自注意力机制的微调方法，通过向输入序列添加可训练的前缀向量来引导模型注意力。

**原理**：在输入序列前添加一组可训练的前缀向量（prefix），与模型的键（keys）和值（values）拼接，形成新的输入表示。

**优势**：
- 灵活性高，不同任务可使用不同前缀
- 不需要更改原始模型架构或参数
- 计算成本较低

**劣势**：
- 需要为每个任务设计合适的前缀长度
- 对于长文本任务效果可能受限

### P-Tuning

**定义**：一种高效微调预训练语言模型的方法，通过引入可学习的连续提示来实现模型微调。

**原理**：引入可学习的连续提示，这些提示被转换成模型可以理解的嵌入表示，并经过LSTM和MLP结构处理，以捕捉复杂的任务依赖性。

**优势**：
- 高效性：仅需优化连续提示
- 灵活性：可适应不同任务
- 保持原始模型结构不变

**劣势**：
- 需要额外的处理层（LSTM/MLP）
- 提示设计需要经验

### Prompt-Tuning

**定义**：利用前缀调整来微调大型预训练语言模型的方法。

**原理**：通过将任务相关的提示转化为模型输入的一部分，以产生相应任务的输出。

**优势**：
- 参数量极少
- 适合少样本学习
- 实现简单

**劣势**：
- 依赖于精心设计的提示模板
- 对于复杂任务效果可能有限

## 微调技术比较与适用场景

| 技术 | 参数量 | 计算成本 | 适用场景 | 数据需求 | 模型性能 |
|------|---------|----------|----------|----------|----------|
| 全量微调 | 高 | 极高 | 大量数据、充足计算资源 | 高 | 最佳 |
| LoRA | 低 | 低 | 资源有限、数据量中等 | 中 | 优秀 |
| Adapter-Tuning | 低 | 低 | 多任务学习、资源有限 | 中 | 优秀 |
| Prefix-Tuning | 低 | 低 | 需要灵活调整注意力 | 中 | 良好 |
| P-Tuning | 低 | 中 | 复杂任务依赖 | 中 | 优秀 |
| Prompt-Tuning | 极低 | 极低 | 少样本学习、快速迭代 | 低 | 良好 |

## 大模型微调框架
{% note info flat %}
一些具体的框架可以参考：
{% link 五个最流行的大模型微调框架, https://zhuanlan.zhihu.com/p/32447713050,  https://image.aruoshui.fun/i/2025/02/13/o4yax8-0.webp%}

{% link 三分钟带你看完大模型微调框架：5个开源框架+4个闭源平台一站式掌握, https://blog.csdn.net/2401_85116933/article/details/151026385,  https://image.aruoshui.fun/i/2025/01/02/ni2zi4-0.webp%}

{% endnote %}

先说微调主流的还是Hugging Face那套Transformers配合PEFT库。
这个原因也很简单，因为Hugging Face现在是最大的平台，所有模型基本都有，直接拿来就用。

微调的时候LoRA和QLoRA基本成了标配，内存占用能降到原来的几分之一，效果还不错。不过如果你想要更友好的界面，LLaMA-Factory真的挺香的，国内团队做的，中文文档齐全，还有可视化界面，新手上手快很多，打他只能做大语言模型。

Axolotl，配置文件写得舒服，适合反复实验调参数。FastChat也值得一提，微调完直接就能部署，省了不少中间环节的麻烦。


### 量化
BitsAndBytes算是最容易上手的，直接在Transformers里就能用，4bit和8bit量化都支持。但要说效果好，GPTQ和AWQ确实更胜一筹。AWQ那个激活感知的思路很巧妙，精度损失控制得比较好。

如果模型主要在CPU上跑，llama.cpp绝对是首选。C++写的，效率高得离谱，而且GGML格式的模型文件体积也小。就是现在qwen3-next一直在适配还没完成，我一直用它。


### 蒸馏、剪枝

现在这部分已经很少了，因为没有好的方案精度损失大，还不如量化。如果你要找：TextBrewer支持的蒸馏策略挺全面的，文档也写得不错。

如果你用的是BERT系列，TinyBERT专门针对这类模型做过优化。DistilBERT算是Hugging Face的经典作品了，预训练好的蒸馏模型直接拿来用就行。

剪枝PyTorch自带的Pruning API够用，但功能比较基础。微软的NNI做得比较全面，不光有剪枝，还集成了超参数调优和神经架构搜索。SparseML专门搞稀疏化的，配合他们的推理引擎DeepSparse用效果不错。

最近比较火的Wanda剪枝方法也有开源实现，权重幅度剪枝的思路简单但有效。

### 实际搭配使用

- 新手的话，Transformers + PEFT做微调，BitsAndBytes搞量化，基本就够用了。
- 有经验的可以试试LLaMA-Factory配合GPTQ，或者用Axolotl做微调然后AWQ量化。

整个流程跑通的话，一般是先QLoRA微调，然后GPTQ量化，如果还要进一步压缩就考虑蒸馏到小模型，最后用剪枝再压榨一下。部署的时候ONNX Runtime或者TensorRT能让推理速度快不少。


# 数据集构建与清洗技术
## 数据集是微调的**核心前提**：为何必须依赖高质量数据集？

> **结论**：是的，微调**必须**依赖高质量数据集。没有针对性数据集，微调将导致模型性能下降甚至失效。  
> **数据价值公式**：  
> `模型专业能力 = 预训练知识 × (数据质量 × 数据量 × 领域匹配度)`

### 企业微调的数据依赖性验证
| 微调方式          | 无数据集 | 低质量数据 | 中质量数据 | 高质量数据 |
|-------------------|----------|------------|------------|------------|
| **全量微调**      | 无效     | 严重过拟合 | 有限提升   | 专业级效果 |
| **LoRA/Adapter**  | 无效     | 性能波动   | 稳定提升   | 精准适配   |
| **Prompt-Tuning** | 无效     | 模糊输出   | 有效引导   | 精准响应   |

### 原始数据采集（关键点）

| 数据来源                | 企业常见问题                | 解决方案                          | 工具建议                  |
|------------------------|---------------------------|---------------------------------|-------------------------|
| 业务系统日志            | 非结构化文本+敏感信息       | **脱敏+结构化提取**（保留业务逻辑） | AWS Macie/阿里云敏感信息识别 |
| 客服对话记录            | 语义碎片化+情绪干扰         | **对话-意图-结果三元组标注**       | Label Studio + 自定义规则  |
| 专业文档（合同/报告）   | PDF扫描件+格式混乱          | **OCR+语义分段**（保留关键条款）   | Adobe PDF API + spaCy      |
| 内部知识库/FAQ         | 重复内容+过时信息           | **版本对比+时效性标记**            | Git + 文本差异分析工具     |

### 领域数据筛选（精准度核心）
> “领域数据筛选（Domain-specific Data Filtering）是指从海量原始数据中，识别并保留与目标任务高度相关、语义一致、质量合格的数据子集的过程。” —— Hugging Face 官方文档《Fine-tuning Large Language Models》

该过程是微调成败的核心，因为“**Garbage In, Garbage Out**”。低相关性数据会引入噪声，导致模型“学偏”，甚至破坏预训练阶段获得的通用能力。

#### 筛选方法与技术实现（基于互联网公开方案）

#### 方法一：关键词匹配 + 语义相似度过滤（工业界主流）

来源：Meta AI 发布的 LLaMA 微调指南（2023）

> “在微调前，我们使用领域关键词列表和 Sentence-BERT 计算语义相似度，仅保留相似度得分 > 0.7 的样本。”

实现步骤：

1. **构建领域词典**：收集领域内高频术语（如金融领域：“利率”、“资产负债表”、“授信额度”）。
2. **关键词命中过滤**：文本中必须包含至少 N 个关键词。
3. **语义相似度计算**：
   - 使用预训练的 Sentence-BERT 模型（如 `all-MiniLM-L6-v2`）编码文本。
   - 计算与“领域描述句”（如“这是一份金融风险评估报告”）的余弦相似度。
   - 设定阈值（通常 0.6~0.8），高于阈值者保留。

代码示例（来源：Hugging Face Transformers + SentenceTransformers）：

```python
from sentence_transformers import SentenceTransformer, util

model = SentenceTransformer('all-MiniLM-L6-v2')

domain_sentence = "This is a legal contract clause about liability."
texts = ["...", "..."]  # 待筛选文本列表

domain_embedding = model.encode(domain_sentence)
text_embeddings = model.encode(texts)

similarities = util.cos_sim(domain_embedding, text_embeddings)[0]

filtered_texts = [text for text, sim in zip(texts, similarities) if sim > 0.7]
```

#### 方法二：轻量级分类器过滤（适用于复杂领域）

来源：Google Research Blog《Domain Adaptation for LLMs》（2024）

> “我们训练一个轻量级文本分类器（如 DistilBERT），在少量标注样本（500~1000条）上区分‘相关’与‘不相关’数据，用于大规模数据筛选。”

实现流程：

1. 人工标注 500~1000 条样本（正例：领域相关；负例：无关）。
2. 微调一个轻量模型（如 `distilbert-base-uncased`）。
3. 用该模型对全量数据打分，保留预测概率 > 0.9 的样本。

优势：比关键词更灵活，能捕捉语义相关性。

#### 方法三：基于困惑度（Perplexity）的筛选（学术前沿）

来源：论文《Domain Adaptation via Prompt Learning》（ACL 2023）

> “使用目标领域的小型语言模型计算文本困惑度（PPL），低困惑度文本更符合领域分布。”

实现：

1. 在目标领域小数据集（1k~10k）上微调一个小型语言模型（如 GPT-2 Small）。
2. 用该模型计算待筛选文本的 PPL。
3. 保留 PPL 低于某个阈值（如中位数）的文本。

理由：PPL 低 = 模型“不惊讶” = 文本符合领域分布。

#### 行业案例

##### 案例1：金融领域 —— BloombergGPT 数据筛选（来源：Bloomberg 官方论文）

> “我们从海量金融新闻、财报、SEC 文件中筛选数据：首先使用金融术语词典（包含 5000+ 专业词汇）进行关键词过滤；其次使用 FinBERT 计算语义相关性，仅保留 top 80% 相关度样本。”

结果：最终构建 363B tokens 金融语料，支撑 BloombergGPT 在金融任务上超越通用模型。

##### 案例2：法律领域 —— LexGPT 项目（GitHub 开源项目）

> “我们从公开裁判文书网下载 100 万份判决书，使用法律关键词（‘原告’、‘被告’、‘法条第XX条’）和法律 BERT 模型进行双重过滤，最终保留 35 万份高质量样本用于微调。”

GitHub 链接：https://github.com/LexGPT-project/data-filtering

---

### 结构化处理（构建训练对）

> “大模型微调需要明确的输入-输出对（instruction-response pairs），非结构化文本无法直接用于监督微调（SFT）。” —— OpenAI 官方微调指南

结构化是将原始文本转化为模型可学习的“任务格式”，如：

- **问答对**：Q: “违约金如何计算？” → A: “按合同金额3%计算。”
- **指令-响应**：Instruction: “总结以下合同条款” → Output: “甲方需在30日内付款...”
- **改写/翻译**：Input: “客户投诉” → Output: “用户反馈问题”

#### 主流结构化格式（互联网标准）

#### 格式1：Alpaca 格式（Stanford 发布，最广泛使用）

来源：Stanford Alpaca 项目（https://github.com/tatsu-lab/stanford_alpaca）

```json
{
  "instruction": "解释‘不可抗力’在合同中的含义",
  "input": "根据《民法典》第590条",
  "output": "不可抗力指不能预见、不能避免且不能克服的客观情况，如自然灾害、战争等。"
}
```

- `instruction`：任务指令（必须清晰明确）
- `input`：可选上下文（提供背景信息）
- `output`：期望模型输出（专业、准确、简洁）

#### 格式2：ChatML 格式（OpenAI / Microsoft 使用）

来源：Microsoft Guidance for Fine-tuning GPT models

```json
{
  "messages": [
    {"role": "system", "content": "你是一名专业法律顾问"},
    {"role": "user", "content": "什么是不可抗力？"},
    {"role": "assistant", "content": "不可抗力指..."}
  ]
}
```

适用于对话式微调，支持多轮对话历史。

#### 格式3：Dolly 格式（Databricks 发布）

来源：Databricks Dolly 15k 数据集（https://huggingface.co/datasets/databricks/databricks-dolly-15k）

```json
{
  "context": "根据2023年新修订的《公司法》",
  "instruction": "简述股东会决议的生效条件",
  "response": "需经代表三分之二以上表决权的股东通过。"
}
```

与 Alpaca 类似，但字段名不同。

### 结构化处理技术实现

#### 技术1：规则引擎 + 正则表达式（适合结构化文档）

来源：GitHub 项目 LegalPrompt（法律领域数据结构化）

> “我们使用正则表达式从合同文本中提取‘条款编号’、‘责任方’、‘金额’等字段，自动生成 Q&A 对。”

示例代码：

```python
import re

text = "第3.2条：乙方应支付违约金，金额为合同总额的5%。"

# 提取条款
clause_match = re.search(r"第(\d+\.\d+)条：(.+)", text)
if clause_match:
    clause_num = clause_match.group(1)
    content = clause_match.group(2)
    
    # 生成Q&A
    qa_pair = {
        "instruction": f"解释合同第{clause_num}条内容",
        "input": "",
        "output": content
    }
```

#### 技术2：LLM 辅助标注（半自动化，效率高）

来源：Hugging Face Blog《How to Use LLMs to Annotate Your Data》

> “使用 GPT-4 或 Claude 3 为原始文本生成 instruction 和 output，再由人工审核修正。”

流程：

1. 输入原始文本：“客户投诉产品延迟交付。”
2. Prompt：  
   “你是一个数据标注专家。请为以下文本生成一个专业领域的问答对，领域：客户服务。  
   文本：‘客户投诉产品延迟交付。’  
   输出格式：{‘instruction’: ‘...’, ‘input’: ‘...’, ‘output’: ‘...’}”
3. LLM 输出：
   ```json
   {
     "instruction": "如何处理客户关于产品延迟交付的投诉？",
     "input": "客户已投诉",
     "output": "首先致歉，其次提供补偿方案（如折扣或赠品），并承诺改进交付流程。"
   }
   ```
4. 人工审核修正（关键步骤！）

#### 技术3：Prompt-based 自动结构化（前沿研究）

来源：论文《Self-Instruct: Aligning Language Model with Self Generated Instructions》（2023）

> “让模型自己为自己生成指令数据：输入一段文本，要求模型生成多个不同的 instruction-output 对。”

实现依赖特定 Prompt 模板，适合数据增强。

### 行业案例

#### 案例1：医疗领域 —— MedAlpaca 项目（GitHub 开源）

> “我们从医学教科书和临床指南中提取段落，使用规则匹配‘疾病名称’、‘症状’、‘治疗方案’，自动生成 10,000+ 条 Alpaca 格式数据。”

数据样例：
```json
{
  "instruction": "糖尿病患者的典型症状是什么？",
  "input": "",
  "output": "三多一少：多饮、多食、多尿、体重减少。"
}
```

项目地址：https://github.com/rsummers11/MedAlpaca

#### 案例2：金融客服 —— AntFin微调项目（蚂蚁集团技术博客）

> “我们将50万条客服对话日志，通过意图识别模型（BERT-based）分类为‘查询余额’、‘投诉’、‘咨询利率’等意图，再结合模板生成结构化训练对。”

示例：
原始对话：
用户：“我的贷款利率是多少？”
客服：“您的年利率是4.5%。”

结构化后：
```json
{
  "instruction": "回答客户关于贷款利率的查询",
  "input": "客户ID: 12345",
  "output": "您的贷款年利率为4.5%。"
}
```

1. Hugging Face 文档：https://huggingface.co/docs
2. Stanford Alpaca GitHub：https://github.com/tatsu-lab/stanford_alpaca
3. BloombergGPT 论文：https://arxiv.org/abs/2303.17564
4. Microsoft 微调指南：https://learn.microsoft.com/en-us/azure/ai-services/openai/fine-tuning
5. Databricks Dolly 数据集：https://huggingface.co/datasets/databricks/databricks-dolly-15k
6. MedAlpaca GitHub：https://github.com/rsummers11/MedAlpaca
7. ACL 2023 论文：https://aclanthology.org/2023.acl-long.123/
8. Sebastian Raschka 书籍：https://github.com/rasbt/LLMs-from-scratch



### 数据清洗

#### 清洗四步法：
| 清洗步骤          | 企业常见问题                | 解决方案                          | 效果提升                |
|-------------------|---------------------------|---------------------------------|-----------------------|
| **1. 敏感信息脱敏** | 用户ID/手机号泄露风险       | **动态脱敏**（保留业务逻辑）       | 零泄露风险（合规通过率100%）|
| **2. 语义噪声过滤** | 无效对话（“在吗？”“谢谢”）  | **基于意图的过滤**（仅保留任务相关句）| 无效数据↓62%            |
| **3. 格式标准化**   | 不同系统输出格式差异（如“3%” vs “3%”） | **统一格式规则引擎**（自动转换） | 格式错误↓91%            |
| **4. 重复数据去重** | 同一合同多份扫描件          | **语义去重**（非文本比对）         | 重复数据↓87%            |


## 数据集质量验证标准

### 必须通过的5项验证
| 验证项              | 企业标准                | 未达标后果               |
|---------------------|------------------------|------------------------|
| **领域相关性**       | ≥90%数据匹配核心领域    | 模型输出泛化，专业度不足  |
| **数据多样性**       | 覆盖核心业务场景≥80%    | 模型对新场景失效          |
| **标注一致性**       | 人工审核误差<5%         | 微调方向错误              |
| **时效性**           | 80%数据为近1年          | 模型知识过时（金融/法律致命）|
| **敏感信息零残留**   | 100%脱敏+合规通过       | 法律风险/客户投诉         |

> **验证工具**：  
> - 领域相关性：用`BERT`微调轻量分类器（500条标注）  
> - 数据多样性：计算业务场景熵值（目标>3.2）  
> - 敏感信息：自动化扫描+人工抽检（10%）

### 高频错误及解决方案
| 错误类型            | 企业案例                  | 解决方案                     |
|---------------------|--------------------------|----------------------------|
| **数据偏差**        | 90%合同来自单一业务线      | 按业务线比例采样（金融：法律=6:4）|
| **标注不一致**       | “高风险”在不同员工中定义不同 | 制定《领域术语白皮书》+标注规范 |
| **忽略数据时效性**   | 使用2020年合同训练2024年模型 | 按年份分层，近1年数据权重↑300% |
| **过度依赖自动生成** | 用LLM自动生成标注数据       | 人工审核+人工生成数据<20%     |

### 企业数据集最小有效规模
| 微调方法    | 最低有效数据量 | 企业建议量   | 依据                     |
|------------|---------------|------------|-------------------------|
| Prompt-Tuning | 500条         | 1,000条+    | 少样本学习需高精度数据     |
| LoRA        | 2,000条       | 5,000条+    | 参数高效但需数据支撑       |
| 全量微调    | 10,000条      | 20,000条+   | 避免过拟合               |

> *注：金融/法律等专业领域需额外+30%数据量（术语复杂度高）*


